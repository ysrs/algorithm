#pragma once

/*
 * 堆排序是不稳定的排序算法，不稳定发生在堆顶元素与A[i]交换的时刻。
 * 比如序列：{ 9, 5, 7, 5 }，堆顶元素是9，堆排序下一步将9和第二个5进行交换，
 * 得到序列 { 5, 5, 7, 9 }，再进行堆调整得到{ 7, 5, 5, 9 }，
 * 重复之前的操作最后得到{ 5, 5, 7, 9 }从而改变了两个5的相对次序。
 */

/*
 * 堆排序是指利用堆这种数据结构所设计的一种选择排序算法。堆是一种近似完全二叉树的结构（通常堆是通过一维数组来实现的），
 * 并满足性质：以最大堆（也叫大根堆、大顶堆）为例，其中父结点的值总是大于它的孩子节点。
 * 
 * 我们可以很容易的定义堆排序的过程：
 * 1. 由输入的无序数组构造一个最大堆，作为初始的无序区
 * 2. 把堆顶元素（最大值）和堆尾元素互换
 * 3. 把堆（无序区）的尺寸缩小1，并调用heapify(A, 0)从新的堆顶元素开始进行堆调整
 * 4. 重复步骤2，直到堆的尺寸为1
 */

 // 从A[i]向下进行堆调整
void Heapify(int A[], int i, int size);

// 建堆，时间复杂度O(n)
int BuildHeap(int A[], int n);

void HeapSort(int A[], int n);


