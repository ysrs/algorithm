#pragma once

/*
 * 归并排序除了可以对数组进行排序，还可以高效的求出数组小和（即单调和）以及数组中的逆序对，详见这篇博文 https://www.jianshu.com/p/3ab5033074f1。
 */


/*
 * 归并排序是创建在归并操作上的一种有效的排序算法，效率为O(nlogn)，1945年由冯・诺伊曼首次提出。
 * 
 * 
 * 归并排序的实现分为递归实现与非递归(迭代)实现。
 * 
 * 递归实现的归并排序是算法设计中分治策略的典型应用，我们将一个大问题分割成小问题分别解决，
 * 然后用所有小问题的答案来解决整个大问题。
 * 
 * 非递归(迭代)实现的归并排序首先进行是两两归并，然后四四归并，
 * 然后是八八归并，一直下去直到归并了整个数组。
 * 
 * 归并排序算法主要依赖归并(Merge)操作。归并操作指的是将两个已经排序的序列合并成一个序列的操作，归并操作步骤如下：
 * 1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
 * 2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
 * 3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
 * 4. 重复步骤3直到某一指针到达序列尾
 * 5. 将另一序列剩下的所有元素直接复制到合并序列尾
 */

 // 分类 -------------- 内部比较排序
 // 数据结构 ---------- 数组
 // 最差时间复杂度 ---- O(nlogn)
 // 最优时间复杂度 ---- O(nlogn)
 // 平均时间复杂度 ---- O(nlogn)
 // 所需辅助空间 ------ O(n)
 // 稳定性 ------------ 稳定


 // 合并两个已排好序的数组A[left...mid]和A[mid+1...right]
void Merge(int A[], int left, int mid, int right);

// 递归实现的归并排序(自顶向下)
void MergeSortRecursion(int A[], int left, int right);

// 非递归(迭代)实现的归并排序(自底向上)
void MergeSortIteration(int A[], int len);

