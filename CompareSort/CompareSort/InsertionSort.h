#pragma once




/*
 *插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，
 *比如量级小于千，那么插入排序还是一个不错的选择。
 *插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，
 *都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。
 *
 *插入排序是一种简单直观的排序算法。它的工作原理非常类似于我们抓扑克牌。
 *对于未排序数据（右手抓到的牌），在已排序列（左手已排好序的牌）中从后向前扫描，找到位置并插入。
 *插入排序在实现上，通常采用in-place排序（即只需要用到O（1）的额外空间），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后移动，为最新元素提供插入空间。
 *具体算法描述如下：
 *1. 从第一个元素开始，钙元素可以认为已经被排序
 *2. 取出下一个元素，在已经排序的元素排列中从后向前扫描
 *3. 如果该元素（已排序）大于新元素，将该元素移动到下一位置
 *4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
 *5. 将新元素插入到该位置
 *6. 重复步骤2~5
 */

 // 分类 ------------- 内部比较排序
 // 数据结构 ---------- 数组
 // 最差时间复杂度 ---- 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)
 // 最优时间复杂度 ---- 最好情况为输入序列是升序排列的,此时时间复杂度O(n)
 // 平均时间复杂度 ---- O(n^2)
 // 所需辅助空间 ------ O(1)
 // 稳定性 ------------ 稳定
void InsertionSort(int iArray[], int iLength);



