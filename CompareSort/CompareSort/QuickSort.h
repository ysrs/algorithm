#pragma once

/*
 * 快速排序是不稳定的排序算法，不稳定发生在基准元素与A[tail+1]交换的时刻。
 * 比如序列：{ 1, 3, 4, 2, 8, 9, 8, 7, 5 }，基准元素是5，一次划分操作后5要和第一个8进行交换，从而改变了两个元素8的相对次序。
 */

/*
 * 快速排序是由东尼・霍尔所发展的一种排序算法。
 * 在平均状况下，排序n个元素要O(nlogn)次比较。
 * 在最坏状况下则需要O(n^2)次比较，但这种状况并不常见。
 * 事实上，快速排序通常明显比其他O(nlogn)算法更快，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。
 * 
 * 快速排序使用分治策略(Divide and Conquer)来把一个序列分为两个子序列。步骤为：
 * 1. 从序列中挑出一个元素，作为"基准"(pivot).
 * 2. 把所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），这个称为分区(partition)操作。
 * 3. 对每个分区递归地进行步骤1~2，递归的结束条件是序列的大小是0或1，这时整体已经被排好序了。
 */


 // 划分函数
int Partition(int A[], int left, int right);

void QuickSort(int A[], int left, int right);

