#pragma once

/*
 * 基数排序的时间复杂度是O(n * dn)，其中n是待排序元素个数，dn是数字位数。
 * 这个时间复杂度不一定优于O(n log n)，dn的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小；
 * dn决定了进行多少轮处理，而n是每轮处理的操作数目。
 * 
 * 如果考虑和比较排序进行对照，基数排序的形式复杂度虽然不一定更小，
 * 但由于不进行比较，因此其基本操作的代价较小，而且如果适当的选择基数，
 * dn一般不大于log n，所以基数排序一般要快过基于比较的排序，比如快速排序。
 * 由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序并不是只能用于整数排序。
 */

/*
 * 基数排序的发明可以追溯到1887年赫尔曼・何乐礼在打孔卡片制表机上的贡献。它是这样实现的：
 * 将所有待比较正整数统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始进行基数为10的计数排序，
 * 一直到最高位计数排序完后，数列就变成一个有序序列（利用了计数排序的稳定性）。
 */

 // 分类 ------------- 内部非比较排序
 // 数据结构 ---------- 数组
 // 最差时间复杂度 ---- O(n * dn)
 // 最优时间复杂度 ---- O(n * dn)
 // 平均时间复杂度 ---- O(n * dn)
 // 所需辅助空间 ------ O(n * dn)
 // 稳定性 ----------- 稳定


// // 最低位优先基数排序
void LsdRadixSort(int A[], int n);


